# -*- coding: utf-8 -*-
"""Simulation Task3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hujTQ6qyEX9-NPn1bD_p4D8ZpGZ0t7rw
"""

from collections import deque
import pandas as pd
import numpy as np
import scipy.stats as st
import matplotlib.pyplot as plt

pd.set_option('display.max_columns', None)

mRT_IAT = int(input("Input mean inter-arrival time of RT messages: "))
#nonRT_IAT = int(input("Input mean inter-arrival time of non RT messages: "))
mRT_ST = int(input("Input mean ST time of an RT message: "))
mnonRT_ST = int(input("Input mean ST time of a nonRT message: "))
batch_size = int(input("Input batch size: "))
total_batches = int(input("Input the total number of batches: "))
mnonRT_IAT = [10, 15, 20, 25, 30, 35, 40]

class Simulator:
  def __init__(self, n_RT=0, n_nonRT=0, s=0, SCL=4, MC=0, RTCL=3, nonRTCL=5, preempted_ST = -1, \
               mRT_IAT=7, mnonRT_IAT=6, mRT_ST=3, mnonRT_ST=3, batch_size = 1000, total_batches = 51):
    self.n_RT = n_RT #number of items in RT queue
    self.n_nonRT = n_nonRT #number of items in non RT queue
    self.s = s #sever status, 0: ideal, 1: servicing RT msg, 2: servicing nonRT msg
    self.SCL = SCL #service clock
    self.MC = MC  #master clock
    self.RTCL = RTCL #next RT packet arrival time
    self.nonRTCL = nonRTCL #next non RT packet arrival time
    self.preempted_ST = preempted_ST #pre-empted service time
    self.mRT_IAT = mRT_IAT #RT msg inter-arrival time mean
    self.mnonRT_IAT = mnonRT_IAT #nonRT msg inter-arrival time mean
    self.mRT_ST = mRT_ST #RT service time mean
    self.mnonRT_ST = mnonRT_ST #nonRT service time mean 
    self.RT_arrivalq = deque([])  #store the arrival time of RT msg
    self.nonRT_arrivalq = deque([])
    self.event_list = [[RTCL, 0], [nonRTCL, 1], [SCL, 2]]
    self.df = pd.DataFrame(columns = ['MC', 'RTCL', 'nonRTCL', 'n_RT', 'n_nonRT', 'SCL', 's', 'preempted_ST'])
    self.RT_completionq = deque([])
    self.nonRT_completionq = deque([])
    self.RT_batch_mean = []
    self.nonRT_batch_mean = []
    self.RT_batch_percentile = []
    self.nonRT_batch_percentile = []
    self.msg_AT = 0#supposed to store the arrival of the current msg being processed 
  
    self.batch_size = batch_size
    self.total_batches = total_batches

  def RT_IA_time(self): return -self.mRT_IAT*np.log(np.random.uniform())
  def nonRT_IA_time(self):  return -self.mnonRT_IAT*np.log(np.random.uniform())
  def RT_S_time(self): return -self.mRT_ST*np.log(np.random.uniform()) 
  def nonRT_S_time(self): return -self.mnonRT_ST*np.log(np.random.uniform())

  def start_simulation(self):

    while len(self.RT_batch_mean) < self.total_batches or len(self.nonRT_batch_mean) < self.total_batches:
      
      if self.SCL == 0:
        event = min(self.event_list[:2])
      else:
        event = min(self.event_list)

      self.MC = event[0]
      if event[1] == 0:
        self.RT_arrival()
      
      elif event[1] == 1:
        self.nonRT_arrival()
      
      elif event[1] == 2:
        self.ST_completion()

  
  def RT_arrival(self):

    self.RT_arrivalq.append(self.RTCL)
    self.n_RT += 1
    
    self.RTCL = self.MC + self.RT_IA_time()

    self.event_list[0][0] = self.RTCL 
    
    if self.n_RT == 1 and self.s!=1:
      
      if self.s == 2:
        self.preempted_ST = self.SCL - self.MC
        if self.preempted_ST > 0: 
          self.n_nonRT += 1
          self.nonRT_arrivalq.appendleft(self.msg_AT)
        elif self.preempted_ST == 0:
          self.preempted_ST = -1
          self.nonRT_completionq.append(self.MC - self.msg_AT)  #non RT msg completes service so is not added back, add to comp q


      self.msg_AT = self.RT_arrivalq.popleft() 
      self.SCL = self.MC + self.RT_S_time()

      self.event_list[2][0] = self.SCL
      self.n_RT -= 1
      self.s = 1


 
  def nonRT_arrival(self):
    
    
    self.nonRT_arrivalq.append(self.nonRTCL)
    self.n_nonRT += 1
    self.nonRTCL = self.MC + self.nonRT_IA_time()
    self.event_list[1][0] = self.nonRTCL 
    
    if self.n_nonRT == 1:
      if self.s == 0:
        self.msg_AT = self.nonRT_arrivalq.popleft()
        self.SCL = self.MC + self.nonRT_S_time()
        self.event_list[2][0] = self.SCL
        self.s = 2
        self.n_nonRT -= 1
    
    

  def ST_completion(self):
        #on event completion add the elapsed time to the queue
    if self.s == 1:
      self.RT_completionq.append(self.MC - self.msg_AT)
      if len(self.RT_completionq) == self.batch_size:
        #one batch is done
        self.RT_batch_mean.append(np.mean(self.RT_completionq))
        self.RT_batch_percentile.append(np.percentile(self.RT_completionq, 95))
        self.RT_completionq = deque([])  #re-initialize the list


    else:    
      self.nonRT_completionq.append(self.MC - self.msg_AT)
      if len(self.nonRT_completionq) == self.batch_size:
        self.nonRT_batch_mean.append(np.mean(self.nonRT_completionq))
        self.nonRT_batch_percentile.append(np.percentile(self.nonRT_completionq, 95))
        self.nonRT_completionq = deque([])


    #set up the next SCL
    if len(self.RT_arrivalq) > 0:
      self.SCL = self.MC + self.RT_S_time()
      self.s = 1
      self.n_RT -= 1
      self.msg_AT = self.RT_arrivalq.popleft()
      self.event_list[2][0] = self.SCL

    elif len(self.nonRT_arrivalq) > 0:
      self.msg_AT = self.nonRT_arrivalq.popleft()
      self.n_nonRT -= 1
      self.s = 2
      
      if self.preempted_ST > 0:
        self.SCL = self.MC + self.preempted_ST
        self.preempted_ST = -1
      else:
        self.SCL = self.MC + self.nonRT_S_time()

      self.event_list[2][0] = self.SCL
    else:
      self.s = 0
      self.SCL = 0
      self.event_list[2][0] = 0

  def simulator_data(self):
    data = [self.MC, self.RTCL, self.nonRTCL, self.n_RT, self.n_nonRT, self.SCL, self.s, self.preempted_ST]
    return data
  
  def write_to_file(self, file_path):
    self.df.to_csv(file_path, index=False)

df_RT_mbatch = pd.DataFrame(columns=['MIAT(nonRT)', 'mean', '95th percentile', 'confidence interval', 'error'])
df_nonRT_mbatch = pd.DataFrame(columns=['MIAT(nonRT)', 'mean', '95th percentile', 'confidence interval', 'error'])
df_RT_pbatch = pd.DataFrame(columns=['MIAT(nonRT)', 'mean', '95th percentile', 'confidence interval', 'error'])
df_nonRT_pbatch = pd.DataFrame(columns=['MIAT(nonRT)', 'mean', '95th percentile', 'confidence interval', 'error'])

"""Result calculation"""

for mean_time in mnonRT_IAT:

  np.random.seed(0)
  simulator = Simulator(n_RT=0, n_nonRT=0, s=2, SCL=4, MC=0, RTCL=3, nonRTCL=5, preempted_ST=-1, \
                        mRT_IAT=mRT_IAT, mnonRT_IAT=mean_time, mRT_ST=mRT_ST, \
                        mnonRT_ST=mnonRT_ST, batch_size=batch_size, total_batches=total_batches)

  simulator.start_simulation()

  simulator.RT_batch_mean = simulator.RT_batch_mean[1:51]
  simulator.RT_batch_percentile = simulator.RT_batch_percentile[1:51]
  simulator.nonRT_batch_mean = simulator.nonRT_batch_mean[1:51]
  simulator.nonRT_batch_percentile = simulator.nonRT_batch_percentile[1:51]

  #for mean batch RT
  rt_mean = np.mean(simulator.RT_batch_mean)
  rt_percentile = np.percentile(simulator.RT_batch_mean, 95)
  rt_confidence_interval = st.t.interval(alpha=0.95, df=len(simulator.RT_batch_mean)-1, loc=rt_mean, scale=st.sem(simulator.RT_batch_mean))
  rt_error = rt_confidence_interval[1] - rt_confidence_interval[0]
  df_RT_mbatch = df_RT_mbatch.append(pd.Series([mean_time, rt_mean, rt_percentile, rt_confidence_interval, rt_error], index=df_RT_mbatch.columns), ignore_index=True)
  #for mean batcb non RT
  nonrt_mean = np.mean(simulator.nonRT_batch_mean)
  nonrt_percentile = np.percentile(simulator.nonRT_batch_mean, 95)
  nonrt_confidence_interval = st.t.interval(0.95, len(simulator.nonRT_batch_mean)-1, nonrt_mean, st.sem(simulator.nonRT_batch_mean))
  nonrt_error = nonrt_confidence_interval[1] - nonrt_confidence_interval[0]
  df_nonRT_mbatch = df_nonRT_mbatch.append(pd.Series([mean_time, nonrt_mean, nonrt_percentile, nonrt_confidence_interval, nonrt_error], index=df_nonRT_mbatch.columns), ignore_index=True)

  #for percentile batch RT
  rt_mean = np.mean(simulator.RT_batch_percentile)
  rt_percentile = np.percentile(simulator.RT_batch_percentile, 95)
  rt_confidence_interval = st.t.interval(alpha=0.95, df=len(simulator.RT_batch_percentile)-1, loc=rt_mean, scale=st.sem(simulator.RT_batch_percentile))
  rt_error = rt_confidence_interval[1] - rt_confidence_interval[0]
  df_RT_pbatch = df_RT_pbatch.append(pd.Series([mean_time, rt_mean, rt_percentile, rt_confidence_interval, rt_error], index=df_RT_pbatch.columns), ignore_index=True)
  #for percentile batch non RT
  nonrt_mean = np.mean(simulator.nonRT_batch_percentile)
  nonrt_percentile = np.percentile(simulator.nonRT_batch_percentile, 95)
  nonrt_confidence_interval = st.t.interval(0.95, len(simulator.nonRT_batch_percentile)-1, nonrt_mean, st.sem(simulator.nonRT_batch_percentile))
  nonrt_error = nonrt_confidence_interval[1] - nonrt_confidence_interval[0]
  df_nonRT_pbatch = df_nonRT_pbatch.append(pd.Series([mean_time, nonrt_mean, nonrt_percentile, nonrt_confidence_interval, nonrt_error], index=df_nonRT_pbatch.columns), ignore_index=True)

print("Observations for RT messages (Mean batches)")
print(df_RT_mbatch)

print("Observations for nonRT messages (Mean batches)")
print(df_nonRT_mbatch)

fig, ax = plt.subplots(figsize=(7,6))

x = np.arange(len(mnonRT_IAT))
width = 0.4

rect1 = ax.bar(x-width/2, height=df_RT_mbatch['mean'], width=width, yerr=df_RT_mbatch['error'], alpha=0.5, ecolor='black', capsize=10, label='RT msgs')
rect2 = ax.bar(x+width/2, height=df_nonRT_mbatch['mean'], width=width, yerr=df_nonRT_mbatch['error'], alpha=0.5, ecolor='black', capsize=10, label='nonRT msgs' )
ax.set_ylabel('Mean Response Time')
ax.set_xlabel('NonRT mean IAT')
ax.set_title('RT vs NonRT Response Time Mean')
ax.set_xticks(x)
ax.set_xticklabels(mnonRT_IAT)
ax.legend()

fig.tight_layout()
plt.show()

print("Observations for RT messages (Percentile batches)")
print(df_RT_pbatch)

print("Observations for nonRT messages (Percentile batches)")
print(df_nonRT_pbatch)

fig, ax = plt.subplots(figsize=(7,6))
x = np.arange(len(mnonRT_IAT))
width = 0.4

rect1 = ax.bar(x-width/2, height=df_RT_pbatch['mean'], width=width, yerr=df_RT_pbatch['error'], alpha=0.5, ecolor='black', capsize=10, label='RT msgs')
rect2 = ax.bar(x+width/2, height=df_nonRT_pbatch['mean'], width=width, yerr=df_nonRT_pbatch['error'], alpha=0.5, ecolor='black', capsize=10, label='nonRT msgs' )
ax.set_ylabel('Mean Response Time')
ax.set_xlabel('NonRT mean IAT')
ax.set_title('RT vs NonRT Response Time Mean')
ax.set_xticks(x)
ax.set_xticklabels(mnonRT_IAT)
ax.legend()


fig.tight_layout()
plt.show()

